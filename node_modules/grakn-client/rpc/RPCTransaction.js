/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("grakn-client/rpc/RPCTransaction", ["require", "exports", "grakn-client/dependencies_internal", "graknlabs-protocol/protobuf/transaction_pb"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseCollector = exports.RPCTransaction = void 0;
    const dependencies_internal_1 = require("grakn-client/dependencies_internal");
    const transaction_pb_1 = __importDefault(require("graknlabs-protocol/protobuf/transaction_pb"));
    class RPCTransaction {
        constructor(grpcClient, type) {
            this._type = type;
            this._conceptManager = new dependencies_internal_1.ConceptManager(this);
            this._logicManager = new dependencies_internal_1.LogicManager(this);
            this._queryManager = new dependencies_internal_1.QueryManager(this);
            this._collectors = new ResponseCollectors(this);
            this._transactionWasClosed = false;
            this._transactionWasOpened = false;
            this._streamIsOpen = false;
            this._grpcClient = grpcClient;
        }
        open(sessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                this.openTransactionStream();
                this._streamIsOpen = true;
                const openRequest = new transaction_pb_1.default.Transaction.Req()
                    .setOpenReq(new transaction_pb_1.default.Transaction.Open.Req()
                    .setSessionId(sessionId)
                    .setType(this._type === dependencies_internal_1.Grakn.TransactionType.READ ? transaction_pb_1.default.Transaction.Type.READ : transaction_pb_1.default.Transaction.Type.WRITE)
                    .setOptions(dependencies_internal_1.ProtoBuilder.options(options)));
                const startTime = new Date().getTime();
                const res = yield this.execute(openRequest, res => res.getOpenRes());
                const endTime = new Date().getTime();
                this._networkLatencyMillis = endTime - startTime - res.getProcessingTimeMillis();
                this._transactionWasOpened = true;
                return this;
            });
        }
        type() {
            return this._type;
        }
        isOpen() {
            return this._transactionWasOpened && !this._transactionWasClosed;
        }
        concepts() {
            return this._conceptManager;
        }
        logic() {
            return this._logicManager;
        }
        query() {
            return this._queryManager;
        }
        commit() {
            return __awaiter(this, void 0, void 0, function* () {
                const commitReq = new transaction_pb_1.default.Transaction.Req()
                    .setCommitReq(new transaction_pb_1.default.Transaction.Commit.Req());
                yield this.execute(commitReq);
            });
        }
        rollback() {
            return __awaiter(this, void 0, void 0, function* () {
                const rollbackReq = new transaction_pb_1.default.Transaction.Req()
                    .setRollbackReq(new transaction_pb_1.default.Transaction.Rollback.Req());
                yield this.execute(rollbackReq);
            });
        }
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._streamIsOpen) {
                    this._streamIsOpen = false;
                    // TODO: close stream, somehow?
                }
                if (!this._transactionWasClosed) {
                    this._transactionWasClosed = true;
                    this._collectors.clearWithError(new ErrorResponse("Transaction closed."));
                }
            });
        }
        execute(request, transformResponse = () => null) {
            const responseCollector = new ResponseCollector();
            const requestId = dependencies_internal_1.uuidv4();
            request.setId(requestId);
            this._collectors.put(requestId, responseCollector);
            // TODO: we can optionally inject the callback here - perhaps that would be cleaner than using ResponseCollectors?
            this._stream.write(request);
            return responseCollector.take().then(transformResponse);
        }
        stream(request, transformResponse) {
            const responseCollector = new ResponseCollector();
            const requestId = dependencies_internal_1.uuidv4();
            request.setId(requestId);
            request.setLatencyMillis(this._networkLatencyMillis);
            this._collectors.put(requestId, responseCollector);
            this._stream.write(request);
            return new dependencies_internal_1.Stream(requestId, this._stream, responseCollector, transformResponse);
        }
        openTransactionStream() {
            this._stream = this._grpcClient.transaction();
            this._stream.on("data", (res) => {
                const requestId = res.getId();
                const collector = this._collectors.get(requestId);
                if (!collector)
                    throw new dependencies_internal_1.GraknClientError(dependencies_internal_1.ErrorMessage.Client.UNKNOWN_REQUEST_ID.message(requestId));
                collector.add(new OkResponse(res));
            });
            this._stream.on("error", (err) => {
                console.error(err);
            });
            this._stream.on("end", () => {
                this._streamIsOpen = false;
                this.close();
            });
            // TODO: look into _stream.on(status) + any other events
        }
    }
    exports.RPCTransaction = RPCTransaction;
    class ResponseCollectors {
        constructor(transaction) {
            this._map = {};
            this._transaction = transaction;
        }
        get(uuid) {
            return this._map[uuid];
        }
        put(uuid, collector) {
            if (this._transaction["_transactionWasClosed"])
                throw new dependencies_internal_1.GraknClientError(dependencies_internal_1.ErrorMessage.Client.TRANSACTION_CLOSED.message());
            this._map[uuid] = collector;
        }
        clearWithError(error) {
            Object.keys(this._map).forEach((requestId) => this._map[requestId].add(error));
            for (const requestId in this._map)
                delete this._map[requestId];
        }
    }
    class ResponseCollector {
        constructor() {
            this._responseBuffer = new dependencies_internal_1.BlockingQueue();
        }
        add(response) {
            this._responseBuffer.add(response);
        }
        take() {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this._responseBuffer.take();
                return response.read();
            });
        }
    }
    exports.ResponseCollector = ResponseCollector;
    class Response {
    }
    class OkResponse extends Response {
        constructor(res) {
            super();
            this._res = res;
        }
        read() {
            return this._res;
        }
        toString() {
            return "OkResponse {" + this._res.toString() + "}";
        }
    }
    class ErrorResponse extends Response {
        constructor(error) {
            super();
            this._error = error;
        }
        read() {
            throw this._error;
        }
        toString() {
            return "ErrorResponse {" + this._error.toString() + "}";
        }
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUlBDVHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9ycGMvUlBDVHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsOEVBU2tDO0lBQ2xDLGdHQUEwRTtJQUsxRSxNQUFhLGNBQWM7UUFjdkIsWUFBWSxVQUFxQixFQUFFLElBQTJCO1lBQzFELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxzQ0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxvQ0FBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxvQ0FBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoRCxJQUFJLENBQUMscUJBQXFCLEdBQUcsS0FBSyxDQUFDO1lBQ25DLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7WUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7WUFDM0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7UUFDbEMsQ0FBQztRQUVLLElBQUksQ0FBQyxTQUFpQixFQUFFLE9BQXNCOztnQkFDaEQsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7Z0JBQzdCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2dCQUUxQixNQUFNLFdBQVcsR0FBRyxJQUFJLHdCQUFnQixDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUU7cUJBQ3JELFVBQVUsQ0FDUCxJQUFJLHdCQUFnQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO3FC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LENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUN4QixDQUFDO1FBRUQsSUFBSTtZQUNBLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN0QixDQUFDO1FBRUQsUUFBUTtZQUNKLE9BQU8saUJBQWlCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDNUQsQ0FBQztLQUNKIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgR3Jha24sXG4gICAgQ29uY2VwdE1hbmFnZXIsXG4gICAgUHJvdG9CdWlsZGVyLFxuICAgIEdyYWtuT3B0aW9ucyxcbiAgICBRdWVyeU1hbmFnZXIsXG4gICAgdXVpZHY0LFxuICAgIEJsb2NraW5nUXVldWUsXG4gICAgU3RyZWFtLCBHcmFrbkNsaWVudEVycm9yLCBFcnJvck1lc3NhZ2UsIExvZ2ljTWFuYWdlcixcbn0gZnJvbSBcIi4uL2RlcGVuZGVuY2llc19pbnRlcm5hbFwiO1xuaW1wb3J0IFRyYW5zYWN0aW9uUHJvdG8gZnJvbSBcImdyYWtubGFicy1wcm90b2NvbC9wcm90b2J1Zi90cmFuc2FjdGlvbl9wYlwiO1xuaW1wb3J0IEdyYWtuUHJvdG8gZnJvbSBcImdyYWtubGFicy1wcm90b2NvbC9wcm90b2J1Zi9ncmFrbl9ncnBjX3BiXCI7XG5pbXBvcnQgR3Jha25HcnBjID0gR3Jha25Qcm90by5HcmFrbkNsaWVudDtcbmltcG9ydCB7IENsaWVudER1cGxleFN0cmVhbSB9IGZyb20gXCJAZ3JwYy9ncnBjLWpzXCI7XG5cbmV4cG9ydCBjbGFzcyBSUENUcmFuc2FjdGlvbiBpbXBsZW1lbnRzIEdyYWtuLlRyYW5zYWN0aW9uIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF90eXBlOiBHcmFrbi5UcmFuc2FjdGlvblR5cGU7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfY29uY2VwdE1hbmFnZXI6IENvbmNlcHRNYW5hZ2VyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2xvZ2ljTWFuYWdlcjogTG9naWNNYW5hZ2VyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3F1ZXJ5TWFuYWdlcjogUXVlcnlNYW5hZ2VyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2NvbGxlY3RvcnM6IFJlc3BvbnNlQ29sbGVjdG9ycztcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9ncnBjQ2xpZW50OiBHcmFrbkdycGM7XG5cbiAgICBwcml2YXRlIF9zdHJlYW06IENsaWVudER1cGxleFN0cmVhbTxUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcSwgVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXM+O1xuICAgIHByaXZhdGUgX3N0cmVhbUlzT3BlbjogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90cmFuc2FjdGlvbldhc09wZW5lZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90cmFuc2FjdGlvbldhc0Nsb3NlZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9uZXR3b3JrTGF0ZW5jeU1pbGxpczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IoZ3JwY0NsaWVudDogR3Jha25HcnBjLCB0eXBlOiBHcmFrbi5UcmFuc2FjdGlvblR5cGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2NvbmNlcHRNYW5hZ2VyID0gbmV3IENvbmNlcHRNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLl9sb2dpY01hbmFnZXIgPSBuZXcgTG9naWNNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLl9xdWVyeU1hbmFnZXIgPSBuZXcgUXVlcnlNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLl9jb2xsZWN0b3JzID0gbmV3IFJlc3BvbnNlQ29sbGVjdG9ycyh0aGlzKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25XYXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25XYXNPcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RyZWFtSXNPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2dycGNDbGllbnQgPSBncnBjQ2xpZW50O1xuICAgIH1cblxuICAgIGFzeW5jIG9wZW4oc2Vzc2lvbklkOiBzdHJpbmcsIG9wdGlvbnM/OiBHcmFrbk9wdGlvbnMpOiBQcm9taXNlPFJQQ1RyYW5zYWN0aW9uPiB7XG4gICAgICAgIHRoaXMub3BlblRyYW5zYWN0aW9uU3RyZWFtKCk7XG4gICAgICAgIHRoaXMuX3N0cmVhbUlzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgY29uc3Qgb3BlblJlcXVlc3QgPSBuZXcgVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXEoKVxuICAgICAgICAgICAgLnNldE9wZW5SZXEoXG4gICAgICAgICAgICAgICAgbmV3IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uT3Blbi5SZXEoKVxuICAgICAgICAgICAgICAgICAgICAuc2V0U2Vzc2lvbklkKHNlc3Npb25JZClcbiAgICAgICAgICAgICAgICAgICAgLnNldFR5cGUodGhpcy5fdHlwZSA9PT0gR3Jha24uVHJhbnNhY3Rpb25UeXBlLlJFQUQgPyBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlR5cGUuUkVBRCA6IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uVHlwZS5XUklURSlcbiAgICAgICAgICAgICAgICAgICAgLnNldE9wdGlvbnMoUHJvdG9CdWlsZGVyLm9wdGlvbnMob3B0aW9ucykpXG4gICAgICAgICAgICApO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5leGVjdXRlKG9wZW5SZXF1ZXN0LCByZXMgPT4gcmVzLmdldE9wZW5SZXMoKSk7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5fbmV0d29ya0xhdGVuY3lNaWxsaXMgPSBlbmRUaW1lIC0gc3RhcnRUaW1lIC0gcmVzLmdldFByb2Nlc3NpbmdUaW1lTWlsbGlzKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uV2FzT3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIHR5cGUoKTogR3Jha24uVHJhbnNhY3Rpb25UeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgcHVibGljIGlzT3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uV2FzT3BlbmVkICYmICF0aGlzLl90cmFuc2FjdGlvbldhc0Nsb3NlZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29uY2VwdHMoKTogQ29uY2VwdE1hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uY2VwdE1hbmFnZXI7XG4gICAgfVxuXG4gICAgcHVibGljIGxvZ2ljKCk6IExvZ2ljTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpY01hbmFnZXI7XG4gICAgfVxuXG4gICAgcHVibGljIHF1ZXJ5KCk6IFF1ZXJ5TWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWVyeU1hbmFnZXI7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNvbW1pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgY29tbWl0UmVxID0gbmV3IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUmVxKClcbiAgICAgICAgICAgIC5zZXRDb21taXRSZXEobmV3IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uQ29tbWl0LlJlcSgpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlKGNvbW1pdFJlcSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHJvbGxiYWNrKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCByb2xsYmFja1JlcSA9IG5ldyBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcSgpXG4gICAgICAgICAgICAuc2V0Um9sbGJhY2tSZXEobmV3IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUm9sbGJhY2suUmVxKCkpO1xuICAgICAgICBhd2FpdCB0aGlzLmV4ZWN1dGUocm9sbGJhY2tSZXEpO1xuICAgIH1cblxuICAgIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAodGhpcy5fc3RyZWFtSXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJlYW1Jc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IGNsb3NlIHN0cmVhbSwgc29tZWhvdz9cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uV2FzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbldhc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0b3JzLmNsZWFyV2l0aEVycm9yKG5ldyBFcnJvclJlc3BvbnNlKFwiVHJhbnNhY3Rpb24gY2xvc2VkLlwiKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4ZWN1dGU8VD4ocmVxdWVzdDogVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXEsIHRyYW5zZm9ybVJlc3BvbnNlOiAocmVzOiBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcykgPT4gVCA9ICgpID0+IG51bGwpOiBQcm9taXNlPFQ+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VDb2xsZWN0b3IgPSBuZXcgUmVzcG9uc2VDb2xsZWN0b3IoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZHY0KCk7XG4gICAgICAgIHJlcXVlc3Quc2V0SWQocmVxdWVzdElkKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdG9ycy5wdXQocmVxdWVzdElkLCByZXNwb25zZUNvbGxlY3Rvcik7XG4gICAgICAgIC8vIFRPRE86IHdlIGNhbiBvcHRpb25hbGx5IGluamVjdCB0aGUgY2FsbGJhY2sgaGVyZSAtIHBlcmhhcHMgdGhhdCB3b3VsZCBiZSBjbGVhbmVyIHRoYW4gdXNpbmcgUmVzcG9uc2VDb2xsZWN0b3JzP1xuICAgICAgICB0aGlzLl9zdHJlYW0ud3JpdGUocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZUNvbGxlY3Rvci50YWtlKCkudGhlbih0cmFuc2Zvcm1SZXNwb25zZSk7XG4gICAgfVxuXG4gICAgc3RyZWFtPFQ+KHJlcXVlc3Q6IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUmVxLCB0cmFuc2Zvcm1SZXNwb25zZTogKHJlczogVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXMpID0+IFRbXSk6IFN0cmVhbTxUPiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29sbGVjdG9yID0gbmV3IFJlc3BvbnNlQ29sbGVjdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWR2NCgpO1xuICAgICAgICByZXF1ZXN0LnNldElkKHJlcXVlc3RJZCk7XG4gICAgICAgIHJlcXVlc3Quc2V0TGF0ZW5jeU1pbGxpcyh0aGlzLl9uZXR3b3JrTGF0ZW5jeU1pbGxpcyk7XG4gICAgICAgIHRoaXMuX2NvbGxlY3RvcnMucHV0KHJlcXVlc3RJZCwgcmVzcG9uc2VDb2xsZWN0b3IpO1xuICAgICAgICB0aGlzLl9zdHJlYW0ud3JpdGUocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtPFQ+KHJlcXVlc3RJZCwgdGhpcy5fc3RyZWFtLCByZXNwb25zZUNvbGxlY3RvciwgdHJhbnNmb3JtUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb3BlblRyYW5zYWN0aW9uU3RyZWFtKCkge1xuICAgICAgICB0aGlzLl9zdHJlYW0gPSB0aGlzLl9ncnBjQ2xpZW50LnRyYW5zYWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fc3RyZWFtLm9uKFwiZGF0YVwiLCAocmVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXMuZ2V0SWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RvciA9IHRoaXMuX2NvbGxlY3RvcnMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICBpZiAoIWNvbGxlY3RvcikgdGhyb3cgbmV3IEdyYWtuQ2xpZW50RXJyb3IoRXJyb3JNZXNzYWdlLkNsaWVudC5VTktOT1dOX1JFUVVFU1RfSUQubWVzc2FnZShyZXF1ZXN0SWQpKTtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQobmV3IE9rUmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3N0cmVhbS5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbUlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogbG9vayBpbnRvIF9zdHJlYW0ub24oc3RhdHVzKSArIGFueSBvdGhlciBldmVudHNcbiAgICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlQ29sbGVjdG9ycyB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbWFwOiB7IFtyZXF1ZXN0SWQ6IHN0cmluZ106IFJlc3BvbnNlQ29sbGVjdG9yIH07XG4gICAgcHJpdmF0ZSByZWFkb25seSBfdHJhbnNhY3Rpb246IFJQQ1RyYW5zYWN0aW9uO1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zYWN0aW9uOiBSUENUcmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICB9XG5cbiAgICBnZXQodXVpZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBbdXVpZF07XG4gICAgfVxuXG4gICAgcHV0KHV1aWQ6IHN0cmluZywgY29sbGVjdG9yOiBSZXNwb25zZUNvbGxlY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25bXCJfdHJhbnNhY3Rpb25XYXNDbG9zZWRcIl0pIHRocm93IG5ldyBHcmFrbkNsaWVudEVycm9yKEVycm9yTWVzc2FnZS5DbGllbnQuVFJBTlNBQ1RJT05fQ0xPU0VELm1lc3NhZ2UoKSk7XG4gICAgICAgIHRoaXMuX21hcFt1dWlkXSA9IGNvbGxlY3RvcjtcbiAgICB9XG5cbiAgICBjbGVhcldpdGhFcnJvcihlcnJvcjogRXJyb3JSZXNwb25zZSkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tYXApLmZvckVhY2goKHJlcXVlc3RJZCkgPT4gdGhpcy5fbWFwW3JlcXVlc3RJZF0uYWRkKGVycm9yKSk7XG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdElkIGluIHRoaXMuX21hcCkgZGVsZXRlIHRoaXMuX21hcFtyZXF1ZXN0SWRdO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlc3BvbnNlQ29sbGVjdG9yIHtcbiAgICBwcml2YXRlIF9yZXNwb25zZUJ1ZmZlcjogQmxvY2tpbmdRdWV1ZTxSZXNwb25zZT47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VCdWZmZXIgPSBuZXcgQmxvY2tpbmdRdWV1ZTxSZXNwb25zZT4oKTtcbiAgICB9XG5cbiAgICBhZGQocmVzcG9uc2U6IFJlc3BvbnNlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQnVmZmVyLmFkZChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdGFrZSgpOiBQcm9taXNlPFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUmVzPiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcmVzcG9uc2VCdWZmZXIudGFrZSgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVhZCgpO1xuICAgIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgUmVzcG9uc2Uge1xuICAgIGFic3RyYWN0IHJlYWQoKTogVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXM7XG59XG5cbmNsYXNzIE9rUmVzcG9uc2UgZXh0ZW5kcyBSZXNwb25zZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfcmVzOiBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcztcblxuICAgIGNvbnN0cnVjdG9yKHJlczogVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXMpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLl9yZXMgPSByZXM7XG4gICAgfVxuXG4gICAgcmVhZCgpOiBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXM7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwiT2tSZXNwb25zZSB7XCIgKyB0aGlzLl9yZXMudG9TdHJpbmcoKSArIFwifVwiO1xuICAgIH1cbn1cblxuY2xhc3MgRXJyb3JSZXNwb25zZSBleHRlbmRzIFJlc3BvbnNlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9lcnJvcjogRXJyb3IgfCBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihlcnJvcjogRXJyb3IgfCBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICByZWFkKCk6IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUmVzIHtcbiAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3I7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIFwiRXJyb3JSZXNwb25zZSB7XCIgKyB0aGlzLl9lcnJvci50b1N0cmluZygpICsgXCJ9XCI7XG4gICAgfVxufVxuIl19
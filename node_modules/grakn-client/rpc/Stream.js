/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("grakn-client/rpc/Stream", ["require", "exports", "graknlabs-grpc-protocol/protobuf/transaction_pb"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stream = void 0;
    const transaction_pb_1 = __importDefault(require("graknlabs-grpc-protocol/protobuf/transaction_pb"));
    class Stream {
        constructor(requestId, writableStream, responseCollector, transformResponse) {
            this._requestId = requestId;
            this._transformResponse = transformResponse;
            this._writableStream = writableStream;
            this._responseCollector = responseCollector;
        }
        [Symbol.asyncIterator]() {
            return __asyncGenerator(this, arguments, function* _a() {
                while (true) {
                    const next = yield __await(this.next());
                    if (next != null)
                        yield yield __await(next);
                    else
                        break;
                }
            });
        }
        next() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                if ((_a = this._receivedAnswers) === null || _a === void 0 ? void 0 : _a.length) {
                    return this._receivedAnswers.shift();
                }
                const res = yield this._responseCollector.take();
                switch (res.getResCase()) {
                    case transaction_pb_1.default.Transaction.Res.ResCase.CONTINUE:
                        const continueReq = new transaction_pb_1.default.Transaction.Req()
                            .setId(this._requestId).setContinue(true);
                        this._writableStream.write(continueReq);
                        return this.next();
                    case transaction_pb_1.default.Transaction.Res.ResCase.DONE:
                        return undefined;
                    case transaction_pb_1.default.Transaction.Res.ResCase.RES_NOT_SET:
                        throw "Missing response";
                    default:
                        this._receivedAnswers = this._transformResponse(res);
                        return this.next();
                }
            });
        }
        collect() {
            var e_1, _a;
            return __awaiter(this, void 0, void 0, function* () {
                const answers = [];
                try {
                    for (var _b = __asyncValues(this), _c; _c = yield _b.next(), !_c.done;) {
                        const answer = _c.value;
                        answers.push(answer);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return answers;
            });
        }
        map(callbackFn) {
            return new Stream(this._requestId, this._writableStream, this._responseCollector, res => this._transformResponse(res).map(callbackFn));
        }
    }
    exports.Stream = Stream;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcnBjL1N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBR0gscUdBQStFO0lBSy9FLE1BQWEsTUFBTTtRQVNmLFlBQW1CLFNBQWlCLEVBQUUsY0FBc0UsRUFDekYsaUJBQW9DLEVBQUUsaUJBQWlFO1lBQ3RILElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO1lBQzVCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxpQkFBaUIsQ0FBQztZQUM1QyxJQUFJLENBQUMsZUFBZSxHQUFHLGNBQWMsQ0FBQztZQUN0QyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsaUJBQWlCLENBQUM7UUFDaEQsQ0FBQztRQUVNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQzs7Z0JBQ3pCLE9BQU8sSUFBSSxFQUFFO29CQUNULE1BQU0sSUFBSSxHQUFHLGNBQU0sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFBLENBQUE7b0JBQzlCLElBQUksSUFBSSxJQUFJLElBQUk7d0JBQUUsb0JBQU0sSUFBSSxDQUFBLENBQUM7O3dCQUN4QixNQUFNO2lCQUNkO1lBQ0wsQ0FBQztTQUFBO1FBRUssSUFBSTs7O2dCQUNOLFVBQUksSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxNQUFNLEVBQUU7b0JBQy9CLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxDQUFDO2lCQUN4QztnQkFFRCxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDakQsUUFBUSxHQUFHLENBQUMsVUFBVSxFQUFFLEVBQUU7b0JBQ3RCLEtBQUssd0JBQWdCLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUTt3QkFDbEQsTUFBTSxXQUFXLEdBQUcsSUFBSSx3QkFBZ0IsQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFOzZCQUNyRCxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDOUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7d0JBQ3hDLE9BQU8sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO29CQUN2QixLQUFLLHdCQUFnQixDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUk7d0JBQzlDLE9BQU8sU0FBUyxDQUFDO29CQUNyQixLQUFLLHdCQUFnQixDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFdBQVc7d0JBQ3JELE1BQU0sa0JBQWtCLENBQUM7b0JBQzdCO3dCQUNJLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ3JELE9BQU8sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2lCQUMxQjs7U0FDSjtRQUVLLE9BQU87OztnQkFDVCxNQUFNLE9BQU8sR0FBUSxFQUFFLENBQUM7O29CQUN4QixLQUEyQixJQUFBLEtBQUEsY0FBQSxJQUFJLENBQUEsSUFBQTt3QkFBcEIsTUFBTSxNQUFNLFdBQUEsQ0FBQTt3QkFDbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDeEI7Ozs7Ozs7OztnQkFDRCxPQUFPLE9BQU8sQ0FBQzs7U0FDbEI7UUFFRCxHQUFHLENBQVUsVUFBaUM7WUFDMUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQzNJLENBQUM7S0FDSjtJQTFERCx3QkEwREMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ2xpZW50V3JpdGFibGVTdHJlYW0gfSBmcm9tIFwiQGdycGMvZ3JwYy1qc1wiO1xuaW1wb3J0IFRyYW5zYWN0aW9uUHJvdG8gZnJvbSBcImdyYWtubGFicy1ncnBjLXByb3RvY29sL3Byb3RvYnVmL3RyYW5zYWN0aW9uX3BiXCI7XG5pbXBvcnQge1xuICAgIFJlc3BvbnNlQ29sbGVjdG9yLFxufSBmcm9tIFwiLi4vZGVwZW5kZW5jaWVzX2ludGVybmFsXCI7XG5cbmV4cG9ydCBjbGFzcyBTdHJlYW08VD4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPFQ+IHtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3JlcXVlc3RJZDogc3RyaW5nO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3dyaXRhYmxlU3RyZWFtOiBDbGllbnRXcml0YWJsZVN0cmVhbTxUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcT47XG4gICAgcHJpdmF0ZSByZWFkb25seSBfcmVzcG9uc2VDb2xsZWN0b3I6IFJlc3BvbnNlQ29sbGVjdG9yO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3RyYW5zZm9ybVJlc3BvbnNlOiAocmVzOiBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcykgPT4gVFtdO1xuXG4gICAgcHJpdmF0ZSBfcmVjZWl2ZWRBbnN3ZXJzOiBUW107XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocmVxdWVzdElkOiBzdHJpbmcsIHdyaXRhYmxlU3RyZWFtOiBDbGllbnRXcml0YWJsZVN0cmVhbTxUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcT4sXG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29sbGVjdG9yOiBSZXNwb25zZUNvbGxlY3RvciwgdHJhbnNmb3JtUmVzcG9uc2U6IChyZXM6IFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUmVzKSA9PiBUW10pIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1SZXNwb25zZSA9IHRyYW5zZm9ybVJlc3BvbnNlO1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0cmVhbSA9IHdyaXRhYmxlU3RyZWFtO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUNvbGxlY3RvciA9IHJlc3BvbnNlQ29sbGVjdG9yO1xuICAgIH1cblxuICAgIGFzeW5jKiBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk6IEFzeW5jSXRlcmF0b3I8VCwgYW55LCB1bmRlZmluZWQ+IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBhd2FpdCB0aGlzLm5leHQoKVxuICAgICAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkgeWllbGQgbmV4dDtcbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBuZXh0KCk6IFByb21pc2U8VD4ge1xuICAgICAgICBpZiAodGhpcy5fcmVjZWl2ZWRBbnN3ZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNlaXZlZEFuc3dlcnMuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX3Jlc3BvbnNlQ29sbGVjdG9yLnRha2UoKTtcbiAgICAgICAgc3dpdGNoIChyZXMuZ2V0UmVzQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uUHJvdG8uVHJhbnNhY3Rpb24uUmVzLlJlc0Nhc2UuQ09OVElOVUU6XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGludWVSZXEgPSBuZXcgVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXEoKVxuICAgICAgICAgICAgICAgICAgICAuc2V0SWQodGhpcy5fcmVxdWVzdElkKS5zZXRDb250aW51ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0YWJsZVN0cmVhbS53cml0ZShjb250aW51ZVJlcSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblByb3RvLlRyYW5zYWN0aW9uLlJlcy5SZXNDYXNlLkRPTkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25Qcm90by5UcmFuc2FjdGlvbi5SZXMuUmVzQ2FzZS5SRVNfTk9UX1NFVDpcbiAgICAgICAgICAgICAgICB0aHJvdyBcIk1pc3NpbmcgcmVzcG9uc2VcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjZWl2ZWRBbnN3ZXJzID0gdGhpcy5fdHJhbnNmb3JtUmVzcG9uc2UocmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0KCk6IFByb21pc2U8VFtdPiB7XG4gICAgICAgIGNvbnN0IGFuc3dlcnM6IFRbXSA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGFuc3dlciBvZiB0aGlzKSB7XG4gICAgICAgICAgICBhbnN3ZXJzLnB1c2goYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5zd2VycztcbiAgICB9XG5cbiAgICBtYXA8VFJlc3VsdD4oY2FsbGJhY2tGbjogKHZhbHVlOiBUKSA9PiBUUmVzdWx0KTogU3RyZWFtPFRSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0odGhpcy5fcmVxdWVzdElkLCB0aGlzLl93cml0YWJsZVN0cmVhbSwgdGhpcy5fcmVzcG9uc2VDb2xsZWN0b3IsIHJlcyA9PiB0aGlzLl90cmFuc2Zvcm1SZXNwb25zZShyZXMpLm1hcChjYWxsYmFja0ZuKSk7XG4gICAgfVxufVxuIl19